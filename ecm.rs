use components::*;

// TODO: write a macro that accepts a set of component definitions and generates
// the appropriate structs, `ComponentType` enum, `Entity`, `ComponentWrapper`
// and `EntityManager`

// so the code below would be output by something like:
// generate_entity_manager_from!(
//   Position{x: int, y: int}
//   Bump(int)
//   Direction(int, int)
// )

pub mod components {
    #[deriving(Eq)]
    pub struct Position{x: int, y: int}
    #[deriving(Eq)]
    pub struct Bump(int);
    #[deriving(Eq)]
    pub struct Direction(int, int);

    pub enum ComponentType {
        tPosition,
        tBump,
        tDirection,
    }

    struct Entity{
        Position: Option<Position>,
        Bump: Option<Bump>,
        Direction: Option<Direction>,
    }

    impl Entity {
        fn new() -> Entity {
            Entity{
                Position: None,
                Bump: None,
                Direction: None,
            }
        }
    }

    enum ComponentWrapper {
        cPosition(Position),
        cBump(Bump),
        cDirection(Direction),
    }

    pub struct EM {
        entities: ~[Entity],
    }

    impl EM {
        pub fn new() -> EM {
            EM{entities: ~[]}
        }

        pub fn new_entity(&mut self) -> int {
            self.entities.push(Entity::new());
            (self.entities.len() - 1) as int
        }

        pub fn has(&self, id: int, ctype: ComponentType) -> bool {
            let e = self.entities[id];
            match ctype {
                tPosition => e.Position.is_some(),
                tBump => e.Bump.is_some(),
                tDirection => e.Direction.is_some(),
            }
        }

        pub fn set(&mut self, id: int, component: ComponentWrapper) {
            let e = &mut self.entities[id];
            match component {
                cPosition(c) => e.Position = Some(c),
                cBump(c) => e.Bump = Some(c),
                cDirection(c) => e.Direction = Some(c),
            }
        }

        // Autogenerated from the list of components
        pub fn set_position(&mut self, id: int, component: Position) {
            self.set(id, cPosition(component));
        }
        pub fn set_bump(&mut self, id: int, component: Bump) {
            self.set(id, cBump(component));
        }
        pub fn set_direction(&mut self, id: int, component: Direction) {
            self.set(id, cDirection(component));
        }

        pub fn get(&self, id: int, ctype: ComponentType) -> ComponentWrapper {
            let e = self.entities[id];
            match ctype {
                tPosition => cPosition(e.Position.unwrap()),
                tBump => cBump(e.Bump.unwrap()),
                tDirection => cDirection(e.Direction.unwrap()),
            }
        }

        // Autogenerated from the list of components
        pub fn get_position(&self, id: int) -> Position {
            match self.get(id, tPosition) {
                cPosition(c) => c,
                _ => unreachable!(),
            }
        }
        pub fn get_bump(&self, id: int) -> Bump {
            match self.get(id, tBump) {
                cBump(c) => c,
                _ => unreachable!(),
            }
        }
        pub fn get_direction(&self, id: int) -> Direction {
            match self.get(id, tDirection) {
                cDirection(c) => c,
                _ => unreachable!(),
            }
        }
    }


}


fn main() {
    let mut ecm = EM::new();
    let e1 = ecm.new_entity();
    assert_eq!(ecm.has(e1, tPosition), false);
    assert_eq!(ecm.has(e1, tBump), false);
    assert_eq!(ecm.has(e1, tDirection), false);
    ecm.set_position(e1, Position{x: 1, y: 1});
    ecm.set_bump(e1, Bump(42));
    assert_eq!(ecm.has(e1, tPosition), true);
    assert_eq!(ecm.has(e1, tBump), true);
    assert_eq!(ecm.has(e1, tDirection), false);
    let pos = ecm.get_position(e1);
    assert_eq!(pos, Position{x: 1, y: 1});
}
