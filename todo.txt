* Use `type Handle<T> =  Rc<RefCell<T>>`
  - will simplify the game state code
* Use `expect(error message)` method instead of `unwrap` for Options
* Use rust-geom for unit type safety (has Point types etc. too)
  - https://github.com/servo/rust-geom
  - docs:  http://doc.servo.org/geom/index.html
* BUG: step by step replay doesn't work
* BUG: Voices and Shadows bodies briefly appear after fadeout
* BUG: leaving the area is broken
* Uncover and unfade the screen on player death
* Stop the High colour animation on player death
* Better display the movement of D monsters:
  - they're moving too fast currently (FPS dependent)
  - we should show a path trail
  - and also slow them down (visually -- so like they move every say 200ms, not every tick)
* Improve the radius calculation by not looking at the points' coordinates but
their actual space each tile represents. The tiles are not points but squares
with an area. This should provide a visually better result (but will be harder
to compute)
* Consider switching to a single precomputed Dijkstra object
  - benchmark this in tcod but I think it should be faster
* Using emhyr with smallintmax and explicit component indexes makes the game significantly
(about twice) faster. But the manual indexes are a huge PITA.
       - macro would be a solution
       - but can we create sequential indexes?
* Speed it up:
  - TODO: add a `name() -> &str` method to the `System` trait (with default
  impl), collect metrics for each system automatically in `World::update`,
  generate stats (system name, mean time) on demand. Print these
  from `main` sorted by avg time on exit. Use u64 to store the aggregate
  - no gameplay benchmark (just the initial screen):
    - master: 40fps
    - no systems: 175fps
    - average elapsed times in miliseconds for individual systems:
# high outliers
3.691964788730    19    tile
1.407352112680    10    movement
1.358316901410    0     turn tick

1.099623239440    3     addiction
0.970633802817    6     AI
0.931253521127    12    interaction
0.849813380282    1     stun effect duration
0.847876760563    4     command logger
0.845862676056    7     dose
0.831024647887    13    bump
0.826845070423    15    will
0.812070422535    2     panic effect duration
0.809221830986    8     panic
0.806130281690    5     input
0.743781690141    9     stun
0.682545774648    17    fade out
0.679024647887    18    color animation
0.664633802817    11    eating
0.663855633803    14    combat
0.646908450704    22    addiction graphics

# low outliers
0.319144366197    20    GUI
0.082823943662    16    exploration
0.004661971830    21    turn

* Add emhyr::ComponentManager::get_opt<T>(&self, entity) -> Option<T>
  - if ecm.has::<T> { ecm.get::<T> } is a fairly common pattern we have
  - maybe have that as the only option once we add Artemis-style componentMappers?
* Consider using deftypes units for the engine (replacing dt_ms: uint with Ms(uint), etc.).
* Add bonuses on superhigh
  - see entities on som >= 98
  - uncover the entire map on som == 99
* background glow for the irresistible area around a dose
* Rename `ExplosionEffect` to `AreaEffect`?
* We need a greater pressure for exploration and leaving the area. In my current
playthroughs I just never care enough to leave.
  - consider tweaking the intoxication gain and drop to create stronger pressure
* Hey, like, just a though: What about an infinite world instead of discrete
  screens?
  - may (suprisingly) provide more variety
  - would fit the exploration feel I'm going for
  - no need to figure out special exit handling, etc. Just go as far as you can/want.
* Add smooth animations for the fade-out when growing Withdrawn
* Don't cover the map with the bottom status bar
* If the attacking entity can't find a path, it shouldn't just wait. Make it
  move in a random direction instead.
* Add different worlds the player can go to when leaving the map
  - this could either be completely random
  - or there may be a fixed or semi-fixed sequence (e.g. 2 tree worlds, than two
  other worlds, then three different worlds, etc.)
  Some notes on different world generation:
  - http://gamedev.stackexchange.com/questions/31241/random-map-generation/31245#31245
* improve level generator not to create blocked entities
* consider restricting the possible ways to leave the map
* Don't allow suicide (if there's a way to avoid it)
  - e.g. fatfingering the arrow when the Depression is near
* Change the rate of the `High` animation based on the intoxication amount
  (very high: fast-paced, should slow down on the way to sobriety)
* Add better effects on player's death:
  1. fade out to red/black completely
  2. uncover the entire map (with a reverse fade)
     - with full colours
     - showing player's corpse
* Move the default gfx config (fullscreen, font path, etc.) to libtcod.cfg
  - that way we won't have to implement a lot of options UI
  - should properly commented, suggesting available font options and such
  Examples:
  - font path
  - font size
  - fullscreen (yes/no)
* Use a config file for other in-game configuration
  TCOD has a builtin format & parser:
  - http://doryen.eptalys.net/data/libtcod/doc/1.5.1/html2/parser_run.html?c=true
  Examples:
  - key bindings
  - colour-blind mode (yes/no)
  - location to the replays
  - location to the saved games?
* Don't remove an entity in `kill_entity` on fadeout (see the TODO in the code)
* Never crash on failure
  - Run the main game in a separate task
  - use task failure-handling to trap the errors
  - generate an error report that the user can send
* Add the Marla Daniels quote
  - When the game is launched and there aren't any saves, it should just jump into the play
    * (that was the genius of Braid)
    * (we can use the unexplored area to show help/hints)
  - Any other time, we'll show the menu with the quote & the load-game option
  - Possibly, we may show it during player's death, if it makes sense
* particle effects on hit/death
* animate player state changes (added/removed will, got stunned, etc.)
* change player's colour on stunned/panicked
* Pick a good colour palette
  - we've been picking up our colours pretty randomly so far, need to polish the
  final look
* save&exit/load game
* make sure it's compatible with the colour blind

* BUG: the game is a bit jerky sometimes
  - doesn't seem to be a (purely) AI thing. Even when we replaced AI for a
  random destination the problem persisted.
  - when we set AI to just always wait, the hangs were still occasionally there.
  They could have been rarer, but they also just may have been harder to notice
  (because the only thing moving was the player)


General code improvements

* Generate tcod using rust-bindgen:

  https://github.com/crabtw/rust-bindgen

  The bindgen pass will evetually be integrated to Rust:

  https://github.com/mozilla/rust/issues/2124

* Switch to `cargo-lite`, release tcod as a separate crate

* Look at our IO code, see if we can utilise read_to_str and
  write_str/write_line
  - https://github.com/mozilla/rust/pull/10861
  - http://static.rust-lang.org/doc/master/complement-cheatsheet.html#how-do-i-iterate-over-the-lines-in-a-file





* wrap tcod::console_t if feasible
* Replace "state_of_mind" with "intoxication" in the code
* write a generic system interface so we can simplify the `update` function.
* write a defsystem macro that handles the system boilerplate?
* save the map state on death/exit in the replay log so we can verify the replay
pass produced the same result.
* Split utils into individual files


* play with integrating different scripting languages:
  - guile
  - racket
  - lua
  - squirrel
  - javascript
  (how hard to integrate with rust? how calling functions per entity from rust?
  how performant running the game loop?)



Notes on tcod:

Fade the entire screen in/out of a colour:
     tcod::console_set_fade(fade: u8, tcod::Color)
     (`fade` is <0, 255>, `Color` is the colour to fade from/to)

(great on death, etc.)


The tcod background flags are confusing and at least in my experiments not
    particularly functional. Just use:

    `tcod::console_put_char_ex` which lets you directly specify both foreground
    and background colours and dosen't use the background flags at all.

There doesn't seem to be a way to mix two cells together, i.e. have a proper
disappearing fade. To do that, we'd probably have to invoke some SDL, or just
switch away from TCOD. Seems to be a limitation of the library. Or as a
kinda-solution, don't use dots for background walkable tiles and instead use a
coloured spaces or something.

I kinda like dots, though. They work better at figuring the distances --
especially wrt diagonals.



Some notes on the entity system and its tuning
----------------------------------------------

Catalogue the data we already have in real use (Dose Response):

1. Throughout the entities' lifetime, what's the ratio of each component type
   vs. the total number of entities?
2. Document all the components that each systems guards on and accesses in the
   body
3. Document the different requirements for each system (have to access all
   entities, can just iterate over an array of components, needs to draw on
   screen, etc.)
4. Document all the high-level operations that an entity manager is required to
   do in each system (set/remove the current entity's component, read other
   entity's components)
5. Determine if it's more costly to iterate over all entities and skip the
   non-matching ones or to try and store everything in a continuous block of
   memory so that each system iterates *only* over the valid entities)

It's quite possible the way we do things is too dynamic for cache-friendliness
to work. If so, consider how would a cache-friendly approach change things and
what to do about it (it quite possibly ain't worth the effort -- we're not being
cache-friendly now anyways).

Posible design ideas:

Store components in variable-sized vectors? E.g. for a 1000 entities, we'd have
one ~[(EntityId, PositionComponent)] array that's pretty much full and another
one that says ~[(EntityId, MonsterComponent)] that's half-empty. For a given
entity, the IDs would match.

  - this wouldn't solve the "Only over Position + Tile" entities/components
  - would solve the "Iterate over a single component type"



Maintain all the possible component groups the systems are interested in. Each
such group has a pointer to all the pertinent components (well, either a poiter
or there's a book-keeping required to keep them all in sync).

I.e. the tile_system expects: Iterator<(EntityId, &PositionComponent,
&TileComponent)> but the movement_system wants: Iterator<(EntityId,
&PositionComponent, &DestinationComponent)>

  - not cache-friendly
  - involved book-keeping
  - systems would only iterate over the entities they care about




Notes on perfect hashing:

Minimal Perfect hashing is a technique that allows us to map the keys to
consecutive integers of the same size. One needs to know all the keys in
advance, but that shouldn't be a problem.

This could be great to solve the dispatch based on component types. However,
there are easier implementations (using a standard hash table, assigning the
keys manually) so this should be explored only when the resulting lib is too
slow/unwieldy.


Some resources:

introduction:  http://stevehanov.ca/blog/index.php?id=119

a fast implementation:  http://iswsa.acm.org/mphf/index.html

librafy for perfect hashing:  http://cmph.sourceforge.net/

another implementation:  http://burtleburtle.net/bob/c/perfect.c
