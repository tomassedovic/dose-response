from __future__ import print_function

import re
import sys


def delimiter(component_statement):
    if component_statement[-1] != '}':
        return ';'
    else:
        return ''

def component_name(component_statement):
    m = re.match(r'\w+\s+(\w+)', component_statement)
    if not m:
        print("Invalid component statement: '%s'" % component_statement)
        exit(1)
    return m.group(1)

def to_snake_case(camel_case_text):
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', camel_case_text)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

entity_template = r'''
struct Entity {
%s
}
impl Entity {
    fn new() -> Entity {
        Entity{
%s
        }
    }
}
'''

component_manager_template = r'''
#[deriving(Eq, ToStr)]
pub struct ID(int);

pub struct ComponentManager {
    priv entities: ~[Entity],
    priv initial_id: ID,
    priv next_id: ID,
}

impl ComponentManager {
pub fn new() -> ComponentManager {
        ComponentManager{
            entities: ~[],
            initial_id: ID(0),
            next_id: ID(0),
        }
    }

    pub fn new_entity(&mut self) -> ID {
        self.entities.push(Entity::new());
        self.next_id = ID(*self.next_id + 1);
        ID(*self.next_id - 1)
    }

    pub fn has_entity(&self, id: ID) -> bool {
        let index = (*id - *self.initial_id) as uint;
        let out_of_bounds = index < 0 || index >= self.entities.len();
        return !out_of_bounds;
    }

    pub fn take_out(&mut self, id: ID) -> Entity {
        let index = (*id - *self.initial_id) as uint;
        if index < 0 || index >= self.entities.len() {
            fail!(format!("Invalid entity ID {}", index))
        } else {
            self.entities.remove(index)
        }
    }

    pub fn iter(&self) -> Map<int, ID, Range<int>> {
        range(*self.initial_id, *self.next_id).map(|index| ID(index))
    }

    pub fn remove_all_entities(&mut self) {
        self.entities.truncate(0);
        self.initial_id = self.next_id;
    }

    // Autogenerated `has_component` methods:
    %s

    // Autogenerated `get_component` methods:
    %s

    // Autogenerated `set component` methods:
    %s

    // Autogenerated `remove component` methods:
    %s
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn clear() {
        let mut ecm = ComponentManager::new();
        ecm.new_entity();
        ecm.new_entity();
        assert_eq!(ecm.iter().len(), 2);
        assert_eq!(ecm.has_entity(ID(0)), true);
        assert_eq!(ecm.has_entity(ID(1)), true);
        assert_eq!(ecm.has_entity(ID(2)), false);
        for id in ecm.iter() {
            assert!(ecm.has_entity(id));
        }
        ecm.remove_all_entities();
        assert_eq!(ecm.has_entity(ID(0)), false);
        assert_eq!(ecm.has_entity(ID(1)), false);
        assert_eq!(ecm.iter().len(), 0);
        ecm.new_entity();
        ecm.new_entity();
        ecm.new_entity();
        assert_eq!(ecm.iter().len(), 3);
        assert_eq!(ecm.has_entity(ID(0)), false);
        assert_eq!(ecm.has_entity(ID(1)), false);
        assert_eq!(ecm.has_entity(ID(2)), true);
        assert_eq!(ecm.has_entity(ID(3)), true);
        assert_eq!(ecm.has_entity(ID(4)), true);
        assert_eq!(ecm.has_entity(ID(5)), false);
        assert_eq!(ecm.has_entity(ID(6)), false);
        for id in ecm.iter() {
            assert!(ecm.has_entity(id));
        }
    }

    #[test]
    fn entity_id_on_add() {
        let mut ecm = ComponentManager::new();
        let e1_id = ecm.new_entity();
        let e2_id = ecm.new_entity();
        assert!(ecm.has_entity(e1_id));
        assert_eq!(e1_id, ID(0));
        assert!(ecm.has_entity(e2_id));
        assert_eq!(e2_id, ID(1));
    }

    #[test]
    fn remove_entity() {
        let mut ecm = ComponentManager::new();
        let e1_id = ecm.new_entity();
        let e2_id = ecm.new_entity();
        assert_eq!(ecm.has_entity(e1_id), true);
        assert_eq!(ecm.has_entity(e2_id), true);
        ecm.take_out(e1_id);
        assert_eq!(ecm.has_entity(e1_id), false);
        assert_eq!(ecm.has_entity(e2_id), true);
    }

    #[test]
    fn add_component() {
       let mut ecm = ComponentManager::new();
       let e = ecm.new_entity();
       assert_eq!(ecm.has_test_struct_component(e), false);
       assert_eq!(ecm.has_test_tuple_component(e), false);
       assert_eq!(ecm.has_test_enum_component(e), false);
       ecm.set_test_struct_component(e, TestStructComponent{x: 1, y: 2});
       assert_eq!(ecm.has_test_struct_component(e), true);
       assert_eq!(ecm.has_test_tuple_component(e), false);
       assert_eq!(ecm.has_test_enum_component(e), false);
       assert_eq!(ecm.get_test_struct_component(e), TestStructComponent{x: 1, y: 2});
    }

}
'''

has_component_template = r'''
    pub fn has_%s(&self, id: ID) -> bool {
        let index = (*id - *self.initial_id) as uint;
        if index < 0 || index >= self.entities.len() {
            fail!(format!("has_component: Invalid entity ID {}.", id.to_str()));
        } else {
            self.entities[index].%s.is_some()
        }
    }
'''

get_component_template = r'''
    pub fn get_%s(&self, id: ID) -> %s {
        let index = (*id - *self.initial_id) as uint;
        if index < 0 || index >= self.entities.len() {
            fail!(format!("get_component: Invalid entity ID {}.", id.to_str()));
        } else {
            self.entities[*id].%s.unwrap()
        }
    }
'''

set_component_template = r'''
    pub fn set_%s(&mut self, id: ID, component: %s) {
        let index = (*id - *self.initial_id) as uint;
        if index < 0 || index >= self.entities.len() {
            fail!(format!("set_component: Invalid entity ID {}.", id.to_str()));
        } else {
            self.entities[*id].%s = Some(component);
        }
    }
'''

remove_component_template = r'''
    pub fn remove_%s(&mut self, id: ID) {
        let index = (*id - *self.initial_id) as uint;
        if index < 0 || index >= self.entities.len() {
            fail!(format!("remove_component: Invalid entity ID {}.", id.to_str()));
        } else {
            self.entities[*id].%s = None;
        }
    }
'''

if __name__ == '__main__':
    is_test = len(sys.argv) == 1
    if is_test:
        component_lines = [
            'struct TestStructComponent{x: int, y: int}',
            'struct TestTupleComponent(int, int)',
            'enum TestEnumComponent{A, B, C}',
        ]
    elif len(sys.argv) == 2:
        input_path = sys.argv[1]
        with open(input_path, 'r') as f:
            component_lines = f.readlines()
    else:
        print("You must pass exactly one argument")
        exit(1)

    component_statements = [l.strip() for l in component_lines]
    components = [component_name(s) for s in component_statements]
    if 'Entity' in components:
       print("'Entity' is a reserved name. You can't use it for a component.")
       exit(1)

    if is_test:
        # Add the necessary imports. In the prod scenario it's the
        # responsibility of prelude because the imports must be at the top od
        # the doc.
        print("use std::iter::{Map, Range};")

    # Define the components structs
    for stat in component_statements:
        if stat[-6:] == '//noeq':
            stat = stat[:-6]
        else:
            print("#[deriving(Eq)]")
        print('pub', stat + delimiter(stat))
        print()  # empty line for readability

    # Define the entity
    print(entity_template % (
        '\n'.join(["%s: Option<%s>," % (to_snake_case(c), c) for c in components]),
        '\n'.join(["%s: None," % to_snake_case(c) for c in components]),
    ))

    has_component_methods = [
        has_component_template % (to_snake_case(c), to_snake_case(c))
        for c in components]

    get_component_methods = [
        get_component_template % (to_snake_case(c), c, to_snake_case(c))
        for c in components]

    set_component_methods = [
        set_component_template % (to_snake_case(c), c, to_snake_case(c))
        for c in components]

    remove_component_methods = [
        remove_component_template % (to_snake_case(c), to_snake_case(c))
        for c in components]

    print(component_manager_template % (
        ''.join(has_component_methods),
        ''.join(get_component_methods),
        ''.join(set_component_methods),
        ''.join(remove_component_methods),
    ))
